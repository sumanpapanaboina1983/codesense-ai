// src/analyzer/documentation-analyzer.ts
/**
 * Analyzes documentation quality and coverage for code entities.
 * Sets hasDocumentation and isDeprecated flags on AST nodes.
 */

import winston from 'winston';
import { AstNode, DocumentationInfo, DocTag } from './types.js';

// =============================================================================
// Documentation Quality Thresholds
// =============================================================================

/**
 * Configuration for what constitutes "meaningful" documentation.
 */
export interface DocumentationConfig {
    /** Minimum characters for documentation to be considered meaningful */
    minDescriptionLength: number;
    /** Whether @param tags count toward documentation completeness */
    requireParamDocs: boolean;
    /** Whether @returns/@return tags count toward documentation completeness */
    requireReturnDocs: boolean;
    /** Minimum percentage of params that must be documented (0-1) */
    minParamDocCoverage: number;
}

export const DEFAULT_DOC_CONFIG: DocumentationConfig = {
    minDescriptionLength: 10,
    requireParamDocs: false,
    requireReturnDocs: false,
    minParamDocCoverage: 0.5,
};

// =============================================================================
// Deprecation Patterns
// =============================================================================

/**
 * Patterns for detecting deprecation across languages.
 */
const DEPRECATION_PATTERNS = {
    // JavaScript/TypeScript
    jsdoc: [
        /@deprecated/i,
    ],
    // Java
    java: [
        /@Deprecated/,
        /@deprecated/i,  // In Javadoc
    ],
    // Python
    python: [
        /warnings\.warn\s*\([^)]*DeprecationWarning/,
        /@deprecated/i,
        /\.\.\s*deprecated::/i,  // Sphinx
        /:deprecated:/i,
    ],
    // Go
    go: [
        /\/\/\s*Deprecated:/i,
        /Deprecated:/,
    ],
    // C#
    csharp: [
        /\[Obsolete/,
        /\[Deprecated/,
        /\/\/\/\s*<remarks>\s*Deprecated/i,
    ],
    // C/C++
    cpp: [
        /\[\[deprecated/,
        /__attribute__\s*\(\s*\(\s*deprecated/,
        /@deprecated/i,  // Doxygen
        /\\deprecated/,  // Doxygen
    ],
};

// =============================================================================
// Documentation Analyzer Class
// =============================================================================

export class DocumentationAnalyzer {
    private logger: winston.Logger;
    private config: DocumentationConfig;

    constructor(logger: winston.Logger, config?: Partial<DocumentationConfig>) {
        this.logger = logger;
        this.config = { ...DEFAULT_DOC_CONFIG, ...config };
    }

    /**
     * Analyze documentation for a single node.
     * Returns whether the node has meaningful documentation.
     */
    analyzeNode(node: AstNode): {
        hasDocumentation: boolean;
        isDeprecated: boolean;
        deprecationReason?: string;
        documentationQuality: DocumentationQuality;
    } {
        const quality = this.assessDocumentationQuality(node);
        const deprecation = this.detectDeprecation(node);

        return {
            hasDocumentation: quality.score >= 0.5,
            isDeprecated: deprecation.isDeprecated,
            deprecationReason: deprecation.reason,
            documentationQuality: quality,
        };
    }

    /**
     * Assess the quality of documentation for a node.
     */
    assessDocumentationQuality(node: AstNode): DocumentationQuality {
        const issues: string[] = [];
        let score = 0;
        let maxScore = 0;

        // Check for any documentation at all
        maxScore += 1;
        const hasAnyDoc = this.hasAnyDocumentation(node);
        if (hasAnyDoc) {
            score += 1;
        } else {
            issues.push('No documentation found');
        }

        // Check description length
        maxScore += 1;
        const description = this.getDescription(node);
        if (description && description.length >= this.config.minDescriptionLength) {
            score += 1;
        } else if (description) {
            issues.push(`Description too short (${description.length} chars, need ${this.config.minDescriptionLength})`);
        }

        // Check description quality (not just auto-generated)
        maxScore += 1;
        if (description && !this.isAutoGeneratedDoc(description)) {
            score += 1;
        } else if (description) {
            issues.push('Documentation appears auto-generated');
        }

        // For functions/methods, check parameter documentation
        if (this.isFunctionLike(node)) {
            const paramCount = node.metrics?.parameterCount ||
                node.properties?.parameterCount ||
                this.estimateParamCount(node);

            if (paramCount > 0) {
                maxScore += 1;
                const dockedParams = this.countDocumentedParams(node);
                const coverage = dockedParams / paramCount;

                if (coverage >= this.config.minParamDocCoverage) {
                    score += 1;
                } else {
                    issues.push(`Only ${Math.round(coverage * 100)}% of parameters documented`);
                }
            }

            // Check return documentation for non-void functions
            if (node.returnType && node.returnType !== 'void' && node.returnType !== 'None') {
                maxScore += 1;
                if (this.hasReturnDocumentation(node)) {
                    score += 1;
                } else {
                    issues.push('Return value not documented');
                }
            }
        }

        // Calculate final score
        const finalScore = maxScore > 0 ? score / maxScore : 0;

        return {
            score: finalScore,
            hasDescription: !!description,
            descriptionLength: description?.length || 0,
            hasParamDocs: this.countDocumentedParams(node) > 0,
            hasReturnDocs: this.hasReturnDocumentation(node),
            issues,
            level: this.getDocLevel(finalScore),
        };
    }

    /**
     * Detect if a node is marked as deprecated.
     */
    detectDeprecation(node: AstNode): {
        isDeprecated: boolean;
        reason?: string;
    } {
        // Check documentationInfo first (most reliable)
        if (node.documentationInfo?.isDeprecated) {
            return {
                isDeprecated: true,
                reason: node.documentationInfo.deprecationReason,
            };
        }

        // Check tags
        if (node.tags) {
            const deprecatedTag = node.tags.find(t =>
                t.tag.toLowerCase() === 'deprecated'
            );
            if (deprecatedTag) {
                return {
                    isDeprecated: true,
                    reason: deprecatedTag.description,
                };
            }
        }

        // Check raw doc comment
        if (node.docComment) {
            const patterns = this.getDeprecationPatterns(node.language);
            for (const pattern of patterns) {
                if (pattern.test(node.docComment)) {
                    // Try to extract reason
                    const reasonMatch = node.docComment.match(/@deprecated\s+(.+?)(?:\n|$)/i);
                    return {
                        isDeprecated: true,
                        reason: reasonMatch?.[1]?.trim(),
                    };
                }
            }
        }

        // Check modifier flags for annotations
        if (node.modifierFlags) {
            const hasDeprecated = node.modifierFlags.some(f =>
                f.toLowerCase().includes('deprecated') ||
                f.toLowerCase().includes('obsolete')
            );
            if (hasDeprecated) {
                return { isDeprecated: true };
            }
        }

        return { isDeprecated: false };
    }

    /**
     * Check if node has any documentation.
     */
    private hasAnyDocumentation(node: AstNode): boolean {
        return !!(
            node.documentation ||
            node.docComment ||
            node.documentationInfo?.summary ||
            (node.tags && node.tags.length > 0)
        );
    }

    /**
     * Get the description text from a node.
     */
    private getDescription(node: AstNode): string | undefined {
        return (
            node.documentationInfo?.summary ||
            node.documentation ||
            this.extractDescriptionFromComment(node.docComment)
        );
    }

    /**
     * Extract description from raw doc comment.
     */
    private extractDescriptionFromComment(comment?: string): string | undefined {
        if (!comment) return undefined;

        // Remove comment markers
        let text = comment
            .replace(/^\/\*\*?/gm, '')
            .replace(/\*\/$/gm, '')
            .replace(/^\s*\*\s?/gm, '')
            .replace(/^\/\/\/?/gm, '')
            .replace(/^#\s?/gm, '')
            .trim();

        // Remove tag lines
        text = text
            .split('\n')
            .filter(line => !line.trim().startsWith('@'))
            .join('\n')
            .trim();

        return text || undefined;
    }

    /**
     * Check if documentation appears to be auto-generated.
     */
    private isAutoGeneratedDoc(description: string): boolean {
        const autoGenPatterns = [
            /^TODO:?\s*$/i,
            /^FIXME:?\s*$/i,
            /^Gets?\s+the\s+\w+\.?$/i,
            /^Sets?\s+the\s+\w+\.?$/i,
            /^The\s+\w+\.?$/i,
            /^Returns?\s+the\s+\w+\.?$/i,
            /^Constructor\.?$/i,
            /^Default\s+constructor\.?$/i,
            /^Creates?\s+a\s+new\s+instance\.?$/i,
            /^Auto-generated/i,
            /^Generated\s+by/i,
        ];

        const trimmed = description.trim();
        return autoGenPatterns.some(p => p.test(trimmed));
    }

    /**
     * Check if node is a function-like construct.
     */
    private isFunctionLike(node: AstNode): boolean {
        const functionKinds = [
            'Function', 'Method', 'TSFunction',
            'JavaMethod', 'GoFunction', 'GoMethod',
            'CSharpMethod', 'CppMethod', 'CFunction',
            'Constructor',
        ];
        return functionKinds.includes(node.kind);
    }

    /**
     * Estimate parameter count from node.
     */
    private estimateParamCount(node: AstNode): number {
        // Check properties
        if (node.properties?.parameters) {
            return (node.properties.parameters as any[]).length;
        }
        if (node.properties?.signatureInfo?.parameterCount) {
            return node.properties.signatureInfo.parameterCount;
        }
        return 0;
    }

    /**
     * Count documented parameters.
     */
    private countDocumentedParams(node: AstNode): number {
        let count = 0;

        // Check tags
        if (node.tags) {
            count += node.tags.filter(t =>
                ['param', 'arg', 'argument'].includes(t.tag.toLowerCase())
            ).length;
        }

        // Check documentationInfo
        if (node.documentationInfo?.tags) {
            count = Math.max(count, node.documentationInfo.tags.filter(t =>
                ['param', 'arg', 'argument'].includes(t.tag.toLowerCase())
            ).length);
        }

        return count;
    }

    /**
     * Check if return value is documented.
     */
    private hasReturnDocumentation(node: AstNode): boolean {
        // Check tags
        if (node.tags) {
            const hasReturn = node.tags.some(t =>
                ['return', 'returns'].includes(t.tag.toLowerCase())
            );
            if (hasReturn) return true;
        }

        // Check documentationInfo
        if (node.documentationInfo?.tags) {
            const hasReturn = node.documentationInfo.tags.some(t =>
                ['return', 'returns'].includes(t.tag.toLowerCase())
            );
            if (hasReturn) return true;
        }

        return false;
    }

    /**
     * Get deprecation patterns for a language.
     */
    private getDeprecationPatterns(language: string): RegExp[] {
        const langLower = language.toLowerCase();

        if (langLower === 'typescript' || langLower === 'javascript') {
            return DEPRECATION_PATTERNS.jsdoc;
        }
        if (langLower === 'java') {
            return DEPRECATION_PATTERNS.java;
        }
        if (langLower === 'python') {
            return DEPRECATION_PATTERNS.python;
        }
        if (langLower === 'go') {
            return DEPRECATION_PATTERNS.go;
        }
        if (langLower === 'c#' || langLower === 'csharp') {
            return DEPRECATION_PATTERNS.csharp;
        }
        if (langLower === 'c' || langLower === 'c++' || langLower === 'cpp') {
            return DEPRECATION_PATTERNS.cpp;
        }

        // Return all patterns as fallback
        return [
            ...DEPRECATION_PATTERNS.jsdoc,
            ...DEPRECATION_PATTERNS.java,
            ...DEPRECATION_PATTERNS.python,
            ...DEPRECATION_PATTERNS.go,
            ...DEPRECATION_PATTERNS.csharp,
            ...DEPRECATION_PATTERNS.cpp,
        ];
    }

    /**
     * Get documentation level from score.
     */
    private getDocLevel(score: number): DocumentationLevel {
        if (score >= 0.8) return 'excellent';
        if (score >= 0.6) return 'good';
        if (score >= 0.4) return 'partial';
        if (score > 0) return 'minimal';
        return 'none';
    }

    /**
     * Analyze documentation for multiple nodes.
     */
    analyzeNodes(nodes: AstNode[]): DocumentationAnalysisResult {
        let documented = 0;
        let undocumented = 0;
        let deprecated = 0;
        let publicUndocumented = 0;
        const qualityDistribution: Record<DocumentationLevel, number> = {
            excellent: 0,
            good: 0,
            partial: 0,
            minimal: 0,
            none: 0,
        };

        for (const node of nodes) {
            // Skip non-documentable nodes
            if (!this.isDocumentableNode(node)) continue;

            const analysis = this.analyzeNode(node);

            if (analysis.hasDocumentation) {
                documented++;
            } else {
                undocumented++;
                if (node.isExported || node.visibility === 'public') {
                    publicUndocumented++;
                }
            }

            if (analysis.isDeprecated) {
                deprecated++;
            }

            qualityDistribution[analysis.documentationQuality.level]++;
        }

        const total = documented + undocumented;
        const coverage = total > 0 ? documented / total : 0;

        return {
            totalDocumentable: total,
            documented,
            undocumented,
            coverage,
            publicUndocumented,
            deprecated,
            qualityDistribution,
        };
    }

    /**
     * Check if a node should be documented.
     */
    private isDocumentableNode(node: AstNode): boolean {
        const documentableKinds = [
            'Class', 'Interface', 'Function', 'Method',
            'JavaClass', 'JavaInterface', 'JavaMethod',
            'GoFunction', 'GoMethod', 'GoStruct', 'GoInterface',
            'CSharpClass', 'CSharpInterface', 'CSharpMethod',
            'CppClass', 'CppMethod', 'CFunction',
            'TSFunction', 'Component',
        ];
        return documentableKinds.includes(node.kind);
    }
}

// =============================================================================
// Types
// =============================================================================

export type DocumentationLevel = 'excellent' | 'good' | 'partial' | 'minimal' | 'none';

export interface DocumentationQuality {
    /** Overall quality score (0-1) */
    score: number;
    /** Whether node has a description */
    hasDescription: boolean;
    /** Length of description */
    descriptionLength: number;
    /** Whether parameters are documented */
    hasParamDocs: boolean;
    /** Whether return value is documented */
    hasReturnDocs: boolean;
    /** Issues found with documentation */
    issues: string[];
    /** Documentation level */
    level: DocumentationLevel;
}

export interface DocumentationAnalysisResult {
    /** Total documentable entities */
    totalDocumentable: number;
    /** Number of documented entities */
    documented: number;
    /** Number of undocumented entities */
    undocumented: number;
    /** Coverage ratio (0-1) */
    coverage: number;
    /** Public APIs without documentation */
    publicUndocumented: number;
    /** Number of deprecated entities */
    deprecated: number;
    /** Distribution of documentation quality levels */
    qualityDistribution: Record<DocumentationLevel, number>;
}

// =============================================================================
// Convenience Functions
// =============================================================================

/**
 * Create a documentation analyzer.
 */
export function createDocumentationAnalyzer(
    logger: winston.Logger,
    config?: Partial<DocumentationConfig>
): DocumentationAnalyzer {
    return new DocumentationAnalyzer(logger, config);
}

/**
 * Quick check if a node has documentation.
 */
export function hasDocumentation(node: AstNode): boolean {
    return !!(
        node.documentation ||
        node.docComment ||
        node.documentationInfo?.summary
    );
}

/**
 * Quick check if a node is deprecated.
 */
export function isDeprecated(node: AstNode): boolean {
    if (node.isDeprecated) return true;
    if (node.documentationInfo?.isDeprecated) return true;
    if (node.tags?.some(t => t.tag.toLowerCase() === 'deprecated')) return true;
    return false;
}

/**
 * Calculate documentation coverage for a list of nodes.
 */
export function calculateDocCoverage(nodes: AstNode[]): number {
    const documentable = nodes.filter(n =>
        ['Class', 'Interface', 'Function', 'Method', 'JavaClass', 'JavaInterface',
         'JavaMethod', 'GoFunction', 'GoMethod', 'CSharpClass', 'CSharpMethod',
         'CppClass', 'CppMethod', 'CFunction', 'TSFunction'].includes(n.kind)
    );

    if (documentable.length === 0) return 1;

    const documented = documentable.filter(hasDocumentation);
    return documented.length / documentable.length;
}
